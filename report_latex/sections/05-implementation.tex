\section{Implementation}\label{sec:implementation}
The M5 simulator has three base functions that it calls: \lstinline{prefetch_init()}, \lstinline{prefetch_access()}, and \lstinline{prefetch_complete()}. In the following RPT and DCPT implementations, only the first two functions are utilized. 

\subsection{RPT}
During the initialization, a table is initialized that stores RPT entries. As shown above in figure \ref{fig:RPT Layout}, the table stores entries which consist of a program counter, previous address, a delta, and then pointers that point to the next and previous entries.

When the access function is called, it means that the L2 cache is called for a memory block. Once this happens, it is checked to see if it results in a miss. If so, the table is scanned to see if the block is already in the table. If it isn't in the table a new entry is generated that will replace the oldest entry if the table is full. Otherwise, it is added to the table and the respective pointers are updated. Once it is added it is updated with the program counter and the number of entries variable is incremented. 

After that, the new delta is calculated by subtracting the last address from the current address. If that new delta matches the one already in the entry, and the prospective block isn't already in the cache, and it's also not in the mshr queue, a prefetch is issued for that block. Then the delta and last address field are updated accordingly for that table entry.

\subsection{DCPT}
During initialization, a table is initialized that that stores DCPT entries. It also contains a variable to keep track of the amount of entries stored in the table. The entries consist of four fields as shown in figure \ref{tab:DCPT}, the program counter, the last address, the last prefetch address, and an array for the deltas. 

When the access function is called, the table is checked to see if that program counter has been referenced before. If the program counter is not in the table, and the table is full, the oldest entry is popped from the table to make room for the new entry. Otherwise, the new entry line is updated with the program counter and the memory address, and then it is pushed to the front of the table. Then, a pointer for the current entry is updated with the newest entry and the number of entries field in the table is incremented.
However, if the program counter was in the table it means that block has been accessed before and then delta calculation can begin. First, the new delta is calculated by subtracting the last address from the current address and then dividing it by the block size. Next, if the delta is not zero, it is added to the delta list. If the delta list was full, the oldest one is popped off and the new one is pushed on it. Then, the last address field is updated with the current address. Next, the last delta pair in the list is stored as variables, and the list is traversed from front to back to detect any matches in the delta buffer. If a match is found, the new address is calculated by adding all the deltas in between multiplied by the block size. Then, that address is pushed to a list of potential prefetch candidates. After that, the candidates need to be filtered to remove those already in-flight (not yet completed requests), in the mshr, and those already fetched in the cache. Then, loop through all the candidates, if it is not in-flight, in the mshr queue, or in the cache, push it to the prefetch list, and add it to the in-flight list. Then, set the last prefetch field in the current entry to point towards the candidate. Finally, loop through the prefetch list and issue a prefetch for each address in the list.
